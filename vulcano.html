<html>

<head>
	<title>Vulcano</title>

	<script src="lib/three.min.js"></script>
	<script src="lib/stats.min.js"></script>
	<script src="lib/Coordinates.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src="lib/OBJLoader.js"></script>
	<script src="lib/MTLLoader.js"></script>
	<script src="lib/SPE.min.js"></script>

	<style>
		p {
			margin: 5px;
			padding-left: 200px;
		}
	</style>

</head>

<body style='margin: 0px'>
	<p id="timeFromPrevious" color="white"></p>
	<p id="timeFromPreviousToNext" color="white"></p>

	<script>

		let scene, camera, renderer, controls, stats, clock, vulcano, hemiLight;
		// Used in initParticles()
		let emitter, particleGroup;

		//variables for ortographic camera
		let viewHeight = 10;
		let aspectRatio = window.innerWidth / window.innerHeight;

		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.OrthographicCamera(-aspectRatio * viewHeight / 2,
				aspectRatio * viewHeight / 2, viewHeight / 2, -viewHeight / 2, -1000, 1000);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			// renderer.setClearColor(0x110100);
			renderer.setPixelRatio(window.devicePixelRatio);
			// renderer.gammaInput = true;
			// renderer.gammaOutput = true;
			// renderer.shadowMap.enabled = true;
			camera.position.set(2, 2, 2);

			hemiLight = new THREE.HemisphereLight(0xff0000, 0x110101, 0.5);
			hemiLight.position.set(0, 128, 0);
			scene.add(hemiLight);

			let dirLight = new THREE.DirectionalLight(0xff25aa, 0.3);
			dirLight.color.setHSL(0.1, 1, 0.95);
			dirLight.position.set(0, 3, 0);
			dirLight.position.multiplyScalar(50);
			scene.add(dirLight);
			// dirLight.castShadow = false;
			// dirLight.shadow.mapSize.width = 1024;
			// dirLight.shadow.mapSize.height = 1024;

			let light = new THREE.PointLight(0xff0000, 1);
			light.position.set(0, 3.5, 0);
			scene.add(light);

			let OBJFile = 'obj/vulcano.obj';
			let MTLFile = 'obj/vulcano.mtl';
			let PNGFile = 'textures/vulcano.png';

			new THREE.MTLLoader()
				.load(MTLFile, function (materials) {
					materials.preload();
					new THREE.OBJLoader()
						.setMaterials(materials)
						.load(OBJFile, function (object) {
							object.castShadow = true;
							object.receiveShadow = true;
							// object.position.y = 0;
							let texture = new THREE.TextureLoader().load(PNGFile);

							object.traverse(function (child) {   // aka setTexture
								if (child instanceof THREE.Mesh) {
									child.material.map = texture;
									// child.castShadow = true;
									// child.receiveShadow = true;
								}
							});
							scene.add(object);
						});
				});

			stats = new Stats();

			clock = new THREE.Clock();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';

			document.body.appendChild(renderer.domElement);
			document.body.appendChild(stats.domElement);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.update();
			controls.maxPolarAngle = Math.PI / 2 - 0.01;

		}


		// Create particle group and emitter
		function initParticles() {
			particleGroup = new SPE.Group({
				texture: {
					value: THREE.ImageUtils.loadTexture('./textures/cloudSml.png')
				},
				maxParticleCount: 800
			});

			emitter = new SPE.Emitter({
				maxAge: {
					value: 25
				},
				position: {
					value: new THREE.Vector3(0, 3, 0),
					spread: new THREE.Vector3(0, 3, 0)
				},

				acceleration: {
					value: new THREE.Vector3(0, -10, 0),
					spread: new THREE.Vector3(10, 0, 10)
				},

				velocity: {
					value: new THREE.Vector3(0, 15, 0),
					spread: new THREE.Vector3(10, 10, 10)
				},

				color: {
					value: [new THREE.Color('red'), new THREE.Color('yellow')]
				},

				size: {
					value: 1
				},

				particleCount: 2000
			});

			particleGroup.addEmitter(emitter);
			scene.add(particleGroup.mesh);

		}

		// Lightning variables
		let maxInterval = 5,
			lightIntensity = 10;
		let initTime = Date.now();
		let time,
			interval,
			timeNext = getRandomBetweenTwoNumbers(3, 5);
		document.getElementById("timeFromPreviousToNext").innerHTML = "Time to the next lightning: " + timeNext;

		function getRandomBetweenTwoNumbers(min, max) {
			min = Math.ceil(min);
  			max = Math.floor(max);
  			return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		function animate() {
			requestAnimationFrame(animate);
			time = Date.now();
			interval = time - initTime;
			document.getElementById("timeFromPrevious").innerHTML = "Time since the last lightning: " + interval / 1000;
			if(Math.floor(interval / 1000) == timeNext) {
				hemiLight.intensity = lightIntensity;
				scene.position.x = .1;
				scene.position.z = -.1;
				setTimeout(function() {
					hemiLight.intensity = 1;
					scene.position.x = 0;
					scene.position.z = 0;
					if(getRandomBetweenTwoNumbers(0, 1))
						setTimeout(function() {
							hemiLight.intensity = lightIntensity;
							scene.position.x = -.1;
							scene.position.z = .1;
							setTimeout(function() {
								hemiLight.intensity = 1;
								scene.position.x = 0;
								scene.position.z = 0;
							}, 100);
						}, 50);
				}, 100);
				timeNext = getRandomBetweenTwoNumbers(3, maxInterval);
				document.getElementById("timeFromPreviousToNext").innerHTML = "Time from the previuos to the next lightning: " + timeNext;
				initTime = time;
			}
			Render(clock.getDelta());
			stats.update();
		}

		function Render(dt) {
			particleGroup.tick(dt);
			renderer.render(scene, camera);
		}
		window.addEventListener('resize', function () {
			let w = window.innerWidth,
				h = window.innerHeight;

			let aspect = w / h;
			camera.left = aspect * viewHeight / -2;
			camera.right = aspect * viewHeight / 2;
			camera.top = viewHeight / 2;
			camera.bottom = -viewHeight / 2;
			camera.updateProjectionMatrix();
			renderer.setSize(w, h);
		},
			false);

		Start();
		initParticles();
		setTimeout(animate, 0);

	</script>
</body>

</html>